# C

## C语言基础

* C语言参考手册地址：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5
* C语言GCC编译命令：https://www.runoob.com/w3cnote/gcc-parameter-detail.html

## 2025年3月12日

### **假如我定义了10个函数但是在主程序中只使用了1个函数，那编译后的机器码会不会把这10个函数全部表达出来呢？**

#### **情况 1：无优化编译（-O0，默认）**

如果使用 **无优化编译**，那么**所有 10 个函数都会被编译并链接**，即使它们没有被主程序调用。

- 这通常是因为编译器不会主动移除未使用的函数，以便调试。
- 生成的可执行文件会包含所有 10 个函数，占用额外的代码空间。

#### **情况 2：开启优化（-O1、-O2、-O3、-Os）**

##### **🔹 `-O1`（基本优化）**

- 开启最基本的优化如：
  - **删除死代码（Dead Code Elimination）**
  - **常量合并（Constant Folding）**
  - **减少寄存器存取**，优化变量存储
  - **简单的循环优化**
  - 但 **不会执行占用大量编译时间的优化**

如果使用 `-O1` 及以上的优化级别，编译器会进行 **“死代码消除（Dead Code Elimination）”**：

##### **🔹 `-O2`（推荐，全面优化）**

在 `-O1` 的基础上，**启用更多优化，提高运行速度但保持稳定性**：

- **循环展开（Loop Unrolling）**：减少循环开销
- **指令调度（Instruction Scheduling）**：调整指令顺序，减少流水线阻塞
- **移除更多死代码**
- **函数内联（Inline Expansion）**：减少函数调用开销
- **全局优化**（如跨函数优化）

示例（`for` 循环优化）：

```
for (int i = 0; i < 100; i++) {
    sum += i;
}
```

**在 `-O2` 下，编译器可能会展开循环，减少循环变量的修改，提高效率**。

- **如果函数没有被调用**，编译器会**在编译阶段直接删除它**，最终不会出现在可执行文件中。

- 例如：

  ```
  #include <stdio.h>
  void used_function() {
      printf("This function is used!\n");
  }
  void unused_function() {
      printf("This function is never called!\n");
  }
  int main() {
      used_function();
      return 0;
  }
  ```

  * 如果 **使用 `gcc -O2` 编译**，`unused_function()` 会被移除，不会出现在最终的二进制文件中。

  **🔹 `-O3`（最高性能优化，但可能增大代码体积）**

  - 在 -O2 基础上，启用 更激进的优化，如：
    - **更深度的循环展开**
    - **自动向量化（Auto-vectorization）**
    - **函数内联优化增强**
    - **预测分支优化（Branch Prediction）**

  示例（自动向量化）：

  ```
  for (int i = 0; i < 1000; i++) {
      a[i] = b[i] + c[i];
  }
  ```

  **在 `-O3` 下，GCC 可能会使用 SIMD 指令（如 AVX、SSE）来并行处理数据，提高执行速度**。

  ⚠ **注意**：`-O3` 可能会 **增加代码体积**，影响 **缓存性能**，在某些场景下反而降低性能。

  ------

  ##### **🔹 `-Os`（优化代码大小）**

  - 在 `-O2` 基础上 **移除增加代码大小的优化**，适用于嵌入式开发。
  - **关闭循环展开** 和 **减少内联**，以换取更小的二进制文件。
  - **适用于存储受限的环境（如嵌入式、微控制器）**。

#### **情况 3：静态库 vs. 共享库**

如果未使用的函数来自于 **静态库（.a）** 或（.so/.dll）**：

- 静态库：
  - **只会链接被使用的函数**，未使用的函数不会进入最终可执行文件。
  - 例如：如果 `unused_function()` 定义在静态库 `libfoo.a`，但未被调用，最终的 `a.out` 不会包含它。
- 共享库：
  - 共享库（`.so` / `.dll`）在运行时加载，不会影响最终可执行文件的大小。
  - 但如果你链接了整个共享库，未使用的函数仍然会存在于 `.so` 文件中，但不会占用最终可执行文件的空间。

------

#### **情况 4：编译器内联优化**

如果函数是 `static` 或 `inline`，编译器可能会直接在调用点展开函数，而不会单独存储该函数：

```
c复制编辑static void unused_function() {
    printf("Never used\n");
}
```

- **如果没有调用它，编译器会彻底移除该函数，不会进入最终的可执行文件。**

------

#### **总结**

| **情况**                   | **未使用的函数是否会进入最终执行文件？**                     |
| -------------------------- | ------------------------------------------------------------ |
| **无优化编译（-O0）**      | ✅ **会**，未使用的函数仍然会被编译和链接                     |
| **开启优化（-O2 及以上）** | ❌ **不会**，编译器会移除未使用的函数                         |
| **静态库（.a）**           | ❌ **不会**，只链接被调用的函数                               |
| **共享库（.so / .dll）**   | ✅ **共享库本身仍然包含未使用的函数**，但不会增加可执行文件大小 |
| **静态 / 内联函数**        | ❌ **不会**，编译器会直接优化掉                               |

👉 **如果你希望移除未使用的代码，可以开启编译优化（如 `-O2`），或者使用 `-ffunction-sections -Wl,--gc-sections` 让链接器删除无用函数。** 🚀

## 数组/函数+指针

* **数组指针**

  本质上是指针但是被数组修饰，即表示一个指针指向了一个数组

  ```
  int arr[5]={0};
  int (*arrP)[5]=arr;//指针指向数组且数组的的大小为5
  ```

  

* **指针数组**

​	本质上是数组但是被指针修饰，表示数组中的元素是指针。	

```
int *P[5]={0};//数组中每个元素都是指针
```

## 文件操作

### 1. **按文件类型分类**

- **文本文件（Text File）**：以可读的字符形式存储数据，例如 `.txt` 文件。
- **二进制文件（Binary File）**：以二进制格式存储数据，例如 `.dat` 文件。

### 2. **按文件操作方式分类**

- **标准 I/O 文件操作（使用 `stdio.h` 提供的函数）**
- **低级文件操作（使用 `unistd.h` 或 `fcntl.h` 提供的系统调用，通常用于 Linux/Unix 系统）**

### 3. **按文件访问模式分类**

C 语言的标准库提供了一系列 `fopen()` 的访问模式：

- **只读模式（"r"）**：文件必须存在，不能写入。
- **只写模式（"w"）**：创建新文件或清空已有文件。
- **追加模式（"a"）**：写入数据到文件末尾，文件不存在则创建。
- **读写模式（"r+"）**：可以读写，文件必须存在。
- **写读模式（"w+"）**：创建新文件，可读写，文件存在则清空。
- **追加读写模式（"a+"）**：读写文件，但只能追加内容，不能修改已有内容。

### 4. **按操作方式分类**

- **文件打开与关闭**：`fopen()`、`fclose()`
- **文件读取**：`fgetc()`、`fgets()`、`fread()`
- **文件写入**：`fputc()`、`fputs()`、`fwrite()`
- **文件定位**：`fseek()`、`ftell()`、`rewind()`
- **错误检测**：`feof()`、`ferror()`

### **总结**

| 操作       | 函数                           | 说明                 |
| ---------- | ------------------------------ | -------------------- |
| 打开文件   | `fopen(filename, mode)`        | 以不同模式打开文件   |
| 关闭文件   | `fclose(fp)`                   | 关闭文件，释放资源   |
| 写入文本   | `fprintf(fp, format, args...)` | 以格式化方式写入数据 |
| 读取文本   | `fgets(buffer, size, fp)`      | 读取一行数据         |
| 逐字读取   | `fgetc(fp)`                    | 读取一个字符         |
| 逐字写入   | `fputc(ch, fp)`                | 写入一个字符         |
| 写入二进制 | `fwrite(ptr, size, count, fp)` | 写入二进制数据       |
| 读取二进制 | `fread(ptr, size, count, fp)`  | 读取二进制数据       |
| 文件定位   | `fseek(fp, offset, origin)`    | 移动文件指针         |
| 取文件位置 | `ftell(fp)`                    | 获取当前文件指针位置 |

