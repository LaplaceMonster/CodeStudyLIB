# C

## C语言基础

* C语言参考手册地址：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5
* C语言GCC编译命令：https://www.runoob.com/w3cnote/gcc-parameter-detail.html

## 2025年3月12日

### **假如我定义了10个函数但是在主程序中只使用了1个函数，那编译后的机器码会不会把这10个函数全部表达出来呢？**

#### **情况 1：无优化编译（-O0，默认）**

如果使用 **无优化编译**，那么**所有 10 个函数都会被编译并链接**，即使它们没有被主程序调用。

- 这通常是因为编译器不会主动移除未使用的函数，以便调试。
- 生成的可执行文件会包含所有 10 个函数，占用额外的代码空间。

#### **情况 2：开启优化（-O1、-O2、-O3、-Os）**

##### **🔹 `-O1`（基本优化）**

- 开启最基本的优化如：
  - **删除死代码（Dead Code Elimination）**
  - **常量合并（Constant Folding）**
  - **减少寄存器存取**，优化变量存储
  - **简单的循环优化**
  - 但 **不会执行占用大量编译时间的优化**

如果使用 `-O1` 及以上的优化级别，编译器会进行 **“死代码消除（Dead Code Elimination）”**：

##### **🔹 `-O2`（推荐，全面优化）**

在 `-O1` 的基础上，**启用更多优化，提高运行速度但保持稳定性**：

- **循环展开（Loop Unrolling）**：减少循环开销
- **指令调度（Instruction Scheduling）**：调整指令顺序，减少流水线阻塞
- **移除更多死代码**
- **函数内联（Inline Expansion）**：减少函数调用开销
- **全局优化**（如跨函数优化）

示例（`for` 循环优化）：

```
for (int i = 0; i < 100; i++) {
    sum += i;
}
```

**在 `-O2` 下，编译器可能会展开循环，减少循环变量的修改，提高效率**。

- **如果函数没有被调用**，编译器会**在编译阶段直接删除它**，最终不会出现在可执行文件中。

- 例如：

  ```
  #include <stdio.h>
  void used_function() {
      printf("This function is used!\n");
  }
  void unused_function() {
      printf("This function is never called!\n");
  }
  int main() {
      used_function();
      return 0;
  }
  ```

  * 如果 **使用 `gcc -O2` 编译**，`unused_function()` 会被移除，不会出现在最终的二进制文件中。

  **🔹 `-O3`（最高性能优化，但可能增大代码体积）**

  - 在 -O2 基础上，启用 更激进的优化，如：
    - **更深度的循环展开**
    - **自动向量化（Auto-vectorization）**
    - **函数内联优化增强**
    - **预测分支优化（Branch Prediction）**

  示例（自动向量化）：

  ```
  for (int i = 0; i < 1000; i++) {
      a[i] = b[i] + c[i];
  }
  ```

  **在 `-O3` 下，GCC 可能会使用 SIMD 指令（如 AVX、SSE）来并行处理数据，提高执行速度**。

  ⚠ **注意**：`-O3` 可能会 **增加代码体积**，影响 **缓存性能**，在某些场景下反而降低性能。

  ------

  ##### **🔹 `-Os`（优化代码大小）**

  - 在 `-O2` 基础上 **移除增加代码大小的优化**，适用于嵌入式开发。
  - **关闭循环展开** 和 **减少内联**，以换取更小的二进制文件。
  - **适用于存储受限的环境（如嵌入式、微控制器）**。

#### **情况 3：静态库 vs. 共享库**

如果未使用的函数来自于 **静态库（.a）** 或（.so/.dll）**：

- 静态库：
  - **只会链接被使用的函数**，未使用的函数不会进入最终可执行文件。
  - 例如：如果 `unused_function()` 定义在静态库 `libfoo.a`，但未被调用，最终的 `a.out` 不会包含它。
- 共享库：
  - 共享库（`.so` / `.dll`）在运行时加载，不会影响最终可执行文件的大小。
  - 但如果你链接了整个共享库，未使用的函数仍然会存在于 `.so` 文件中，但不会占用最终可执行文件的空间。

------

#### **情况 4：编译器内联优化**

如果函数是 `static` 或 `inline`，编译器可能会直接在调用点展开函数，而不会单独存储该函数：

```
c复制编辑static void unused_function() {
    printf("Never used\n");
}
```

- **如果没有调用它，编译器会彻底移除该函数，不会进入最终的可执行文件。**

------

#### **总结**

| **情况**                   | **未使用的函数是否会进入最终执行文件？**                     |
| -------------------------- | ------------------------------------------------------------ |
| **无优化编译（-O0）**      | ✅ **会**，未使用的函数仍然会被编译和链接                     |
| **开启优化（-O2 及以上）** | ❌ **不会**，编译器会移除未使用的函数                         |
| **静态库（.a）**           | ❌ **不会**，只链接被调用的函数                               |
| **共享库（.so / .dll）**   | ✅ **共享库本身仍然包含未使用的函数**，但不会增加可执行文件大小 |
| **静态 / 内联函数**        | ❌ **不会**，编译器会直接优化掉                               |

👉 **如果你希望移除未使用的代码，可以开启编译优化（如 `-O2`），或者使用 `-ffunction-sections -Wl,--gc-sections` 让链接器删除无用函数。** 🚀

## 数组/函数+指针

* **数组指针**

  本质上是指针但是被数组修饰，即表示一个指针指向了一个数组

  ```
  int arr[5]={0};
  int (*arrP)[5]=arr;//指针指向数组且数组的的大小为5
  ```

  

* **指针数组**

​	本质上是数组但是被指针修饰，表示数组中的元素是指针。	

```
int *P[5]={0};//数组中每个元素都是指针
```

## 文件操作

### 1. **按文件类型分类**

- **文本文件（Text File）**：以可读的字符形式存储数据，例如 `.txt` 文件。
- **二进制文件（Binary File）**：以二进制格式存储数据，例如 `.dat` 文件。

### 2. **按文件操作方式分类**

- **标准 I/O 文件操作（使用 `stdio.h` 提供的函数）**
- **低级文件操作（使用 `unistd.h` 或 `fcntl.h` 提供的系统调用，通常用于 Linux/Unix 系统）**

### 3. **按文件访问模式分类**

C 语言的标准库提供了一系列 `fopen()` 的访问模式：

- **只读模式（"r"）**：文件必须存在，不能写入。
- **只写模式（"w"）**：创建新文件或清空已有文件。
- **追加模式（"a"）**：写入数据到文件末尾，文件不存在则创建。
- **读写模式（"r+"）**：可以读写，文件必须存在。
- **写读模式（"w+"）**：创建新文件，可读写，文件存在则清空。
- **追加读写模式（"a+"）**：读写文件，但只能追加内容，不能修改已有内容。

### 4. **按操作方式分类**

- **文件打开与关闭**：`fopen()`、`fclose()`
- **文件读取**：`fgetc()`、`fgets()`、`fread()`
- **文件写入**：`fputc()`、`fputs()`、`fwrite()`
- **文件定位**：`fseek()`、`ftell()`、`rewind()`
- **错误检测**：`feof()`、`ferror()`

### **总结**

| 操作       | 函数                           | 说明                 |
| ---------- | ------------------------------ | -------------------- |
| 打开文件   | `fopen(filename, mode)`        | 以不同模式打开文件   |
| 关闭文件   | `fclose(fp)`                   | 关闭文件，释放资源   |
| 写入文本   | `fprintf(fp, format, args...)` | 以格式化方式写入数据 |
| 读取文本   | `fgets(buffer, size, fp)`      | 读取一行数据         |
| 逐字读取   | `fgetc(fp)`                    | 读取一个字符         |
| 逐字写入   | `fputc(ch, fp)`                | 写入一个字符         |
| 写入二进制 | `fwrite(ptr, size, count, fp)` | 写入二进制数据       |
| 读取二进制 | `fread(ptr, size, count, fp)`  | 读取二进制数据       |
| 文件定位   | `fseek(fp, offset, origin)`    | 移动文件指针         |
| 取文件位置 | `ftell(fp)`                    | 获取当前文件指针位置 |

## **1. 代码区（Text Segment）**

### **定义：**

代码区是存储程序**执行指令**的地方，也就是存储程序的机器码。这个区域通常是只读的，因此程序不能在运行时修改自己。

### **特点：**

- **只读性**：代码区一般是只读的，防止程序通过错误修改程序的指令。
- **不可修改**：程序在运行时不能修改代码区中的内容。
- **共享**：如果多个程序运行相同的程序代码（如多个相同的程序实例），它们的代码段会被操作系统共享，这样可以节省内存空间。
- **位置**：代码区通常位于内存的低地址部分。

### **例子：**

```
#include <stdio.h>

int add(int a, int b) {
    return a + b;  // 代码区存放的是 add 函数的指令
}

int main() {
    int result = add(1, 2);
    printf("结果是：%d\n", result);
    return 0;
}
```

`add()` 函数的指令存储在代码区。

------

## **2. 数据区（Data Segment）**

### **定义：**

数据区用于存储程序中**已初始化的全局变量**和**静态变量**（包括常量）。数据区通常分为两个部分：

- **已初始化的数据区（Initialized Data Segment）**：存储程序中初始化的全局变量和静态变量。
- **未初始化的数据区（BSS Segment）**：存储程序中没有显式初始化的全局变量和静态变量，默认初始化为 0 或空值。

### **特点：**

- **存储全局变量和静态变量**：程序中的全局变量、静态变量（包括局部静态变量）都存储在数据区。
- **初始化的变量**存储在已初始化数据区，**未初始化的变量**存储在 BSS 区。
- **程序开始时加载**：数据区中的变量在程序加载时就已经准备好。

### **例子：**

```
#include <stdio.h>

int global_var = 5;  // 存储在已初始化的数据区

static int static_var = 10;  // 存储在已初始化的数据区

int main() {
    static int local_static = 20;  // 存储在已初始化的数据区
    printf("global_var = %d\n", global_var);
    printf("static_var = %d\n", static_var);
    printf("local_static = %d\n", local_static);
    return 0;
}
```

- `global_var`、`static_var` 和 `local_static` 都存储在数据区。

------

## **3. 堆区（Heap）**

### **定义：**

堆区用于动态内存分配，也就是说，它存储的是**由程序动态分配的内存**，如通过 `malloc()`、`calloc()`、`realloc()` 等函数申请的内存空间。

### **特点：**

- **动态分配**：堆区的内存是在程序运行时动态分配的，需要手动管理（使用 `free()` 函数释放）。
- **大小可变**：堆区的大小不固定，可以在运行时按需分配和释放。
- **内存泄漏**：如果在堆区分配的内存没有被正确释放，或者在 `free()` 后仍然访问这块内存，就会出现**内存泄漏**或**野指针**问题。
- **由操作系统管理**：操作系统通过内存管理策略来管理堆区的内存分配。

### **例子：**

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    int *ptr = (int *)malloc(5 * sizeof(int));  // 动态分配内存
    if (ptr == NULL) {
        printf("内存分配失败\n");
        return 1;
    }

    for (int i = 0; i < 5; i++) {
        ptr[i] = i + 1;  // 初始化堆区内存
    }

    for (int i = 0; i < 5; i++) {
        printf("%d ", ptr[i]);  // 打印堆区数据
    }

    free(ptr);  // 释放堆区内存
    return 0;
}
```

`malloc()` 分配的内存位于堆区，`free()` 用于释放这块内存。

------

## **4. 栈区（Stack）**

### **定义：**

栈区用于存储**局部变量**和**函数调用时的参数**。栈是由系统自动管理的，栈空间的大小一般是固定的，由操作系统根据程序的需要分配。

### **特点：**

- **自动管理**：栈上的内存由编译器自动管理。函数调用时，局部变量会被压入栈中，函数返回时，栈上的内存会自动清理。
- **快速分配和释放**：栈是后进先出（LIFO）结构，内存的分配和释放非常快速。
- **限制性**：栈的大小有限，过大的局部变量或递归深度可能导致栈溢出（Stack Overflow）。
- **局部变量和函数调用参数**：存储在栈区的主要是局部变量、函数参数以及函数的返回地址。

### **例子：**

```
#include <stdio.h>

void func() {
    int local_var = 10;  // 存储在栈区
    printf("local_var = %d\n", local_var);
}

int main() {
    func();  // 调用时，局部变量 `local_var` 被压入栈
    return 0;
}
```

在 `func()` 函数内部，局部变量 `local_var` 存储在栈区。

------

## **5. 内存四区总结**

| 区域       | 存储内容                                                 | 生命周期     | 特点                                      |
| ---------- | -------------------------------------------------------- | ------------ | ----------------------------------------- |
| **代码区** | 程序的执行指令（机器码）                                 | 程序运行期间 | 只读，多个进程共享                        |
| **数据区** | 已初始化的全局变量和静态变量                             | 程序运行期间 | 包含已初始化（Data）和未初始化（BSS）区域 |
| **堆区**   | 动态分配的内存，如通过 `malloc()`、`calloc()` 分配的内存 | 手动管理     | 程序运行时动态分配，需手动释放            |
| **栈区**   | 局部变量、函数参数和返回地址                             | 函数调用期间 | 自动管理，快速分配和释放                  |

------

### **6. 总结**

- **代码区**存储程序的指令，是只读的，并且多个进程共享。
- **数据区**存储全局变量和静态变量，包括已初始化和未初始化的部分。
- **堆区**用于动态内存分配，程序运行时按需分配和释放。
- **栈区**存储局部变量和函数调用时的参数，管理自动且高效，但受到栈大小的限制。