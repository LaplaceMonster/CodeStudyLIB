# C

## C语言基础

* C语言参考手册地址：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5
* C语言GCC编译命令：https://www.runoob.com/w3cnote/gcc-parameter-detail.html

## 编译优化问题

### **假如我定义了10个函数但是在主程序中只使用了1个函数，那编译后的机器码会不会把这10个函数全部表达出来呢？**

#### **情况 1：无优化编译（-O0，默认）**

如果使用 **无优化编译**，那么**所有 10 个函数都会被编译并链接**，即使它们没有被主程序调用。

- 这通常是因为编译器不会主动移除未使用的函数，以便调试。
- 生成的可执行文件会包含所有 10 个函数，占用额外的代码空间。

#### **情况 2：开启优化（-O1、-O2、-O3、-Os）**

##### **🔹 `-O1`（基本优化）**

- 开启最基本的优化如：
  - **删除死代码（Dead Code Elimination）**
  - **常量合并（Constant Folding）**
  - **减少寄存器存取**，优化变量存储
  - **简单的循环优化**
  - 但 **不会执行占用大量编译时间的优化**

如果使用 `-O1` 及以上的优化级别，编译器会进行 **“死代码消除（Dead Code Elimination）”**：

##### **🔹 `-O2`（推荐，全面优化）**

在 `-O1` 的基础上，**启用更多优化，提高运行速度但保持稳定性**：

- **循环展开（Loop Unrolling）**：减少循环开销
- **指令调度（Instruction Scheduling）**：调整指令顺序，减少流水线阻塞
- **移除更多死代码**
- **函数内联（Inline Expansion）**：减少函数调用开销
- **全局优化**（如跨函数优化）

示例（`for` 循环优化）：

```
for (int i = 0; i < 100; i++) {
    sum += i;
}
```

**在 `-O2` 下，编译器可能会展开循环，减少循环变量的修改，提高效率**。

- **如果函数没有被调用**，编译器会**在编译阶段直接删除它**，最终不会出现在可执行文件中。

- 例如：

  ```
  #include <stdio.h>
  void used_function() {
      printf("This function is used!\n");
  }
  void unused_function() {
      printf("This function is never called!\n");
  }
  int main() {
      used_function();
      return 0;
  }
  ```

  * 如果 **使用 `gcc -O2` 编译**，`unused_function()` 会被移除，不会出现在最终的二进制文件中。

  **🔹 `-O3`（最高性能优化，但可能增大代码体积）**

  - 在 -O2 基础上，启用 更激进的优化，如：
    - **更深度的循环展开**
    - **自动向量化（Auto-vectorization）**
    - **函数内联优化增强**
    - **预测分支优化（Branch Prediction）**

  示例（自动向量化）：

  ```
  for (int i = 0; i < 1000; i++) {
      a[i] = b[i] + c[i];
  }
  ```

  **在 `-O3` 下，GCC 可能会使用 SIMD 指令（如 AVX、SSE）来并行处理数据，提高执行速度**。

  ⚠ **注意**：`-O3` 可能会 **增加代码体积**，影响 **缓存性能**，在某些场景下反而降低性能。

  ------

  ##### **🔹 `-Os`（优化代码大小）**

  - 在 `-O2` 基础上 **移除增加代码大小的优化**，适用于嵌入式开发。
  - **关闭循环展开** 和 **减少内联**，以换取更小的二进制文件。
  - **适用于存储受限的环境（如嵌入式、微控制器）**。

#### **情况 3：静态库 vs. 共享库**

如果未使用的函数来自于 **静态库（.a）** 或（.so/.dll）**：

- 静态库：
  - **只会链接被使用的函数**，未使用的函数不会进入最终可执行文件。
  - 例如：如果 `unused_function()` 定义在静态库 `libfoo.a`，但未被调用，最终的 `a.out` 不会包含它。
- 共享库：
  - 共享库（`.so` / `.dll`）在运行时加载，不会影响最终可执行文件的大小。
  - 但如果你链接了整个共享库，未使用的函数仍然会存在于 `.so` 文件中，但不会占用最终可执行文件的空间。

------

#### **情况 4：编译器内联优化**

如果函数是 `static` 或 `inline`，编译器可能会直接在调用点展开函数，而不会单独存储该函数：

```
c复制编辑static void unused_function() {
    printf("Never used\n");
}
```

- **如果没有调用它，编译器会彻底移除该函数，不会进入最终的可执行文件。**

------

#### **总结**

| **情况**                   | **未使用的函数是否会进入最终执行文件？**                     |
| -------------------------- | ------------------------------------------------------------ |
| **无优化编译（-O0）**      | ✅ **会**，未使用的函数仍然会被编译和链接                     |
| **开启优化（-O2 及以上）** | ❌ **不会**，编译器会移除未使用的函数                         |
| **静态库（.a）**           | ❌ **不会**，只链接被调用的函数                               |
| **共享库（.so / .dll）**   | ✅ **共享库本身仍然包含未使用的函数**，但不会增加可执行文件大小 |
| **静态 / 内联函数**        | ❌ **不会**，编译器会直接优化掉                               |

👉 **如果你希望移除未使用的代码，可以开启编译优化（如 `-O2`），或者使用 `-ffunction-sections -Wl,--gc-sections` 让链接器删除无用函数。** 🚀